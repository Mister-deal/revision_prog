// See https://aka.ms/new-console-template for more informationusing fonction_dotNet;using System;namespace fonction_dotNet{    class Program    {        static void Main(string[] args)        {            /*            Console.WriteLine("Hello World!");            Class1.afficherSéparateur();            Console.WriteLine("ceci est un test");            Class1.afficherSéparateur();            Console.WriteLine(Class1.additionner(15, 15));            Console.WriteLine(Class1.estPair(15));            Console.WriteLine(Class1.CalculerPrixTTC(100));            Console.WriteLine(Class1.multiplier(15, 12, 10));            Console.WriteLine(Class1.multiplier(10, 12));            int t = 5;            int u = 10;            //en définissant les variables en tant que variable globale, alors les fonctions peuvent avoir accès aux variables            //elle est définie au niveau de la classe            void FoncA()            {                //elle est locale                Console.WriteLine(t);                Console.WriteLine(u);            }            void FoncB()            {                Console.WriteLine(u);                //comme elle est locale, u ne peut fonctionner ici car elle ne dispose pas de la portée nécessaire                //u va donc générer une erreur de compilation                t = 7;            }            FoncA();            FoncB();            Class1.DireBonjour();            Class1 salutation = new Class1();            salutation.DireBonjourPersonnalise("maxime");            Class1.AnalyseNombres(new[] { 1, 2, 3, 4, 5, 6 });            Func<int, int> triple = x => x * 3;            int resultat = triple(10);            Console.WriteLine(resultat);            Action<string> annoncer = message => Console.WriteLine("Annonce : " + message);            annoncer("fin de l'exercice");            List<int> nombres = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };            nombres.RemoveAll(x => x % 2 != 0);            Console.WriteLine("Nombres pairs restants :");            foreach (int n in nombres)            {                Console.WriteLine(n);            }            //exercice 9.1            //une fonction en c# est un bloc de code intégrant un type, des paramètres, un nom et pouvant remplir une fonction, exemple additionner ou bien soustraire une donnée. les utilisations sont multiples et son avantage repose dans sa modularité.            //le mot clé que l'on utilise pour ne renvoyer aucune valeur est VOID. si on essaie d'utiliser return dans une fonction void, ça va créer une erreur car la fonction ne peut retourner une valeur grâce à return            // un paramètre est une variable associée à une fonction, introduite comme paramètre, tandis qu'un argument est quand on appelle une fonction et l'on intéragit avec selon son type et son fonctionnement.            // public static void analyserValeurs(String a)            //Public permet de définir la visibilité de la fonction, static permet de définir si la fonction est instanciable ou non. une fonction disposant de static peut être appelée sans instancier un objet où la fonction s'y trouve. void permet de définir si la fonction renvoie oui ou non une valeur à la fin à travers l'utilisation de Return. dans ce contexte, non. AnalyserValeurs est le nom de la fonction, tandis que string a, quant à lui, est le paramètre de la fonction.            //la surcharge de fonctions fait référence au polymorphisme de surcharge. l'utilisation du polymorphisme est le suivant: il permet de créer deux fonctions disposant du même nom mais dont le comportement diffère, par exemple avec les paramètres, en incluant également le type.            //non, ce n'est pas possible car le compilateur considèrera ceci comme une erreur, sachant que si deux fonctions du même nom existe mais sans paramètre pour les différencier, le compilateur renverra une erreur.            //int n ne pourra être utilisé en dehors de la fonction calculer car elle est une variable de fonction, semblable à une variable locale. si on avait voulu qu'elle soit utilisable, il aurait fallu que la variable soit globale, dans le sens où elle fait partie de la classe et non de la fonction.            //demarrer() est appelé par le fait de devoir définir le nom de la classe puis d'appeler par la suite la fonction (ex: Voiture.Demarrer()) tandis que dans l'exemple de calculerDistance, un objet faisant partie de la classe voiture doit être instancié (ex: Voiture auto = new voiture();) après avoir instancié l'objet, l'on peut par la suite utiliser la fonction CalculerDistance()            //une fonction locale est une fonction intégrée à l'intérieur d'une autre fonction afin de rendre le tout plus modulaire et plus lisible, surtout pour faciliter l'utilisation de certaines fonctions.            //les fonctions anonymes sont des méthodes sans nom, dont le but est de créer des délégués ou des expressions lambda. ça permet l'écriture de blocs de code qui peuvent être passés comme arguments ou stockés dans des variables de délégués.            //première règle: toujours bien nommer ses variables et fonctions afin qu'elles respectent ce que tu cherches à faire. si tu cherches à créer une fonction pour additionner des valeurs, la nommer "additionner" est déjà meilleur que devoir la nommer en abrégée ou avec un nom différent ne permettant pas d'identifier au premier abord l'utilité de la fonction.            //seconde règle: Subdiviser les fonctions en de nombreuses fonctions ou bien songer à créer des fonctions locales pour séparer la logique algorithmique et métier.            //exercice 9.2            Console.WriteLine(NotesUtil.CalculerMoyenne(340, 5));            Console.WriteLine(NotesUtil.CalculerMoyenne([12, 15, 13, 10, 12]));            */            /*            Console.WriteLine("--- Gestionnaire de notes ---");            int nombreDeNotes;            do{                Console.Write("Combien de notes souhaitez-vous entrer ? ");                string input = Console.ReadLine();            if (int.TryParse(input, out nombreDeNotes) && nombreDeNotes >= 0)            {                break;            }            else            {                Console.WriteLine("Veuillez entrer un nombre entier valide et non négatif.");            }        } while (true);        List<int> listeDeNotes = new List<int>();        for (int i = 0; i < nombreDeNotes; i++)        {            int note;            do            {                Console.Write($"Entrez la note #{i + 1} : ");                string inputNote = Console.ReadLine();                if (int.TryParse(inputNote, out note) && note >= 0 && note <= 100) // Supposons des notes entre 0 et 100                {                    listeDeNotes.Add(note);                    break;                }                else                {                    Console.WriteLine("Veuillez entrer une note entière valide (par exemple, entre 0 et 100).");                }            } while (true);        }        int[] tableauDeNotes = listeDeNotes.ToArray();        double moyenneDesNotes = NotesUtil.CalculerMoyenne(tableauDeNotes);        Console.WriteLine($"\nLa moyenne des notes est : {moyenneDesNotes:F2}"); // :F2 formate en 2 décimales        Console.WriteLine("\nAppuyez sur n'importe quelle touche pour quitter.");        Console.ReadKey();    }        */                         GestionnaireStock.AjouterProduit("Pommes", 10);            GestionnaireStock.AjouterProduit("Bananes", 5);            GestionnaireStock.RetirerProduit("Pommes", 3);            GestionnaireStock.RetirerProduit("Bananes", 10);            GestionnaireStock.AfficherStock();                    }    }}